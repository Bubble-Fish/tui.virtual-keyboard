tui.util.defineNamespace("fedoc.content", {});
fedoc.content["VirtualKeyboard.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview The module that capture keys typed from user.\n * @author NHN Ent. FE dev team. &lt;dl_javascript@nhnent.com>\n * @dependency jquery-1.8.3.min.js, tui-code-snippet.js\n */\n\n/**\n * A virtual keyboard component is capturing kyes that is typed from user.\n * @constructor VirtualKeyboard\n * @example\n * // Create VirtualKeyboard instance with array of keyboard\n * var vkeyboard = new tui.component.VirtualKeyboard({\n *      container: 'vkeyboard', // container element id\n *      keyType: 'number', // keyboard type\n *      functions: { // function key location\n *          shuffle: 0,\n *          language: 2,\n *          caps: 3,\n *          symbol: 4,\n *          remove: 5,\n *          clear: 9,\n *          space: 10,\n *          close: 11,\n *          done: 20\n *      },\n *      keys: [\"9\", \"3\", \"5\", \"1\", \"\", \"7\", \"0\", \"2\", \"4\", \"6\", \"8\", \"\"], // all keys but function keys.\n *      template: { // html templatet for key elements\n *          key: '&lt;li class=\"subcon\">&lt;span class=\"btn_key\">&lt;button type=\"button\">{KEY}&lt;/button>&lt;/span>&lt;/li>',\n *          blank: '&lt;li class=\"subcon\">&lt;span class=\"btn_key\">&lt;/span>&lt;/li>',\n *          shuffle: '&lt;li class=\"subcon\">&lt;span class=\"btn btn_reload\">&lt;button type=\"button\" value=\"shuffle\">재배열&lt;/button>&lt;/span>&lt;/li>',\n *          remove: '&lt;li class=\"subcon last\">&lt;span class=\"btn btn_del\">&lt;button type=\"button\" value=\"remove\">&lt;span class=\"sp\">삭제&lt;/span>&lt;/button>&lt;/span>&lt;/li>'\n *      },\n *      callback: { // callback for function or normal keys\n *          key: function() { //run },          // A callback that is called when user type or touch key (but function key)\n *          remove: function() { //run },\n *          getKeys: function() { //run }        // A callback that called  rearrange keys\n *      },\n *      isClickOnly: false\n * });\n */\nvar VirtualKeyboard = tui.util.defineClass(/** @lends VirtualKeyboard.prototype */{\n    /**\n     * Default html template for keys\n     * @readonly\n     * @type {object}\n     * @private\n     */\n    _template: {\n        key: '&lt;li>&lt;button type=\"button\" value=\"{KEY}\">{KEY}&lt;/button>&lt;/li>',\n        blank: '&lt;li>&lt;/li>'\n    },\n\n    /**\n     * A map data for fixed keys(function keys)\n     * @type {object}\n     * @private\n     */\n    _fixedKeys: {},\n\n    /**\n     * A array for unfixed keys' order.\n     * @type {array}\n     * @private\n     */\n    _rawKeys: [],\n\n    /**\n     * A array for blank keys' order\n     * @type {array}\n     * @private\n     */\n    _identifiedRawKeys: [],\n\n    /*** \n     * The map data for vertual keyboard\n     * @type {object}\n     * @private\n     */\n    _keyMap: {},\n\n    /**\n     * A array of all of keys(fixed, unfixed)' order\n     * @type {array}\n     * @private\n     */\n    _keySequences: [],\n\n    /**\n     * A map for callback supposed to run for keys\n     * @type {object}\n     * @private\n     */\n    _callback: {},\n\n    /**\n     * Key type of current keyboard\n     * @type {string}\n     * @private\n     */\n    _currentKeyType: null,\n\n    /**\n     * Whether english keyboard or not\n     * @type {boolean}\n     * @private\n     */\n    _isEnglish: false,\n\n    /**\n     * Whether symbol letter keyboard or not\n     * @type {boolean}\n     * @private\n     */\n    _isSymbol: false,\n\n    /**\n     * whether caps lock or not\n     * @type {boolean}\n     * @private\n     */\n    _isCapsLock: false,\n\n    /**\n     * The documentFragment inpromtu pool for saving key element\n     * @type {element}\n     * @private\n     */\n    _documentFragment: null,\n\n    /**\n     * Initalize \n\t * @param {object} [options] Options to initialize component\n     */\n    init: function(options) {\n        this._initVariables(options || {});\n\n        this._arrangeKeySequence();\n        this._refineKeyMap();\n        this._initKeyboard(options.container);\n\n        this._attachEvent(options.isClickOnly);\n    },\n\n    /**\n     * Initialize private files\n     * @param {object} options  Options to initialize keyboard\n     * @private\n     */\n    _initVariables: function(options) {\n        this._currentKeyType = options.keyType || 'english';\n        this._fixedKeys = options.functions || {};\n        this._rawKeys = this._copyArray(options.keys);\n        this._template = tui.util.extend(this._template, options.template);\n        this._callback = options.callback || {};\n        this._documentFragment = document.createDocumentFragment();\n    },\n\n    /**\n     * Binds event\n     * @param {boolean} isClickOnly A option to decide to ignore touchevent\n     * @private\n     */\n    _attachEvent: function(isClickOnly) {\n        var isSupportTouch = !isClickOnly &amp;&amp; (('createTouch' in document) || ('ontouchstart' in document));\n        var eventType = isSupportTouch ? 'touchstart' : 'click';\n        this._$container.on(eventType, $.proxy(this._pressKeyHandler, this));\n    },\n\n    /**\n     * Handler for click or touch buttons\n     * @param {object} event A event object\n     * @private\n     */\n    _pressKeyHandler: function(event) {\n        var targetButton = this._getTargetButton(event.target);\n        var keyName, keyGroup, index;\n\n          if(!tui.util.isExisty(targetButton)) {\n            return false;\n        }\n\n        keyName = targetButton.value;\n        keyGroup = this._getKeyGroup(keyName);\n        index = this._keyMap[keyName].rawIndex;\n\n        if(keyGroup === 'key') {\n            this._executeCallback(keyGroup, index);\n        } else {\n            this[keyName]();\n            this._executeCallback(keyName);\n        }\n    },\n\n    /**\n     * Returns clicked/touched elements of keys\n     * @param {element} targetElement A clicked/touched html element\n     * @returns {*}\n     * @private\n     */\n    _getTargetButton: function(targetElement) {\n        if(targetElement.tagName.toUpperCase() === 'BUTTON') {\n            return targetElement;\n        } else {\n            return $(targetElement).parent('button')[0];\n        }\n    },\n\n    /**\n     * Create keys array for virtual keyboard\n     * @private\n     */\n    _arrangeKeySequence: function() {\n        var sortedKeys;\n\n        // Sort fixed keys by index\n        sortedKeys = this._sortFixedKeys();\n\n        // Copy recieved key array\n        this._identifyRawKeys();\n        this._copyArray(this._identifiedRawKeys, this._keySequences);\n\n        // Insert fixed key \n        tui.util.forEach(sortedKeys, function(value, index) {\n            if(tui.util.isExisty(value)) {\n                this._keySequences.splice(this._fixedKeys[value], 0, value);\n            }\n        }, this);\n    },\n\n    /**\n     * Inject key value to find blank key\n     * @private\n     */\n    _identifyRawKeys: function() {\n        var blankCount = 0;\n        tui.util.forEach(this._rawKeys, function(value, index) {\n            if(this._getKeyGroup(value) === 'blank') {\n                value = 'blank' + blankCount;\n                blankCount++;\n            }\n            this._identifiedRawKeys[index] = value;\n        }, this);\n    },\n\n    /**\n     * Copy array (not deep copy)\n     * @param {array} originalArray Original array\n     * @param {array} [copyArray] New array\n     * @returns {*} \n     * @private\n     */\n    _copyArray: function(originalArray, copyArray) {\n        if(!tui.util.isExisty(originalArray)) {\n            return false;\n        }\n        if(!tui.util.isArray(originalArray)) {\n            originalArray = [originalArray];\n        }\n        if(!tui.util.isExisty(copyArray) || !tui.util.isArray(copyArray)) {\n            copyArray = [];\n        }\n\n        tui.util.forEach(originalArray, function(value, index) {\n            copyArray[index] = value;\n        }, this);\n\n        return copyArray;\n    },\n\n    /**\n     * Sort fixed keys.\n     * @returns {Array} Fixed keys' array that is sorted by index\n     * @private\n     */\n    _sortFixedKeys : function() {\n        var sortedKeys;\n        this._keySequences.length = 0;\n\n        sortedKeys = tui.util.keys(this._fixedKeys) || [];\n        sortedKeys.sort($.proxy(function(a, b) {\n            return this._fixedKeys[a] - this._fixedKeys[b];\n        }, this));\n\n        return sortedKeys;\n    },\n\n    /**\n     * Create map data by key information\n     * @private\n     */\n    _refineKeyMap: function() {\n        this._refineFixedKeys();\n        this._refineFloatingKeys();\n    },\n\n    /**\n     * Redefine fixed keys map\n     * @private\n     */\n    _refineFixedKeys: function() {\n        tui.util.forEach(this._fixedKeys, function(value, key) {\n            this._keyMap[key] = {\n                key: key,\n                rawIndex: null,\n                positionIndex: value,\n                keyGroup: this._getKeyGroup(key)\n            };\n        }, this);\n    },\n\n    /**\n     * Redefine unfixed keys map\n     * @private\n     */\n    _refineFloatingKeys: function() {\n        tui.util.forEach(this._identifiedRawKeys, function(value, index) {\n            if(tui.util.isExisty(this._keyMap[value])) {\n                // v1.0.0:: Exist case, only change positionIndex\n                this._keyMap[value].positionIndex = this._getPositionIndex(value);\n\n                // v1.1.0:: Exist case, change positionIndex with **rawIndex**\n                this._keyMap[value].rawIndex = index;\n            } else {\n                // Create new map data\n                this._keyMap[value] = {\n                    key: value,\n                    rawIndex: index,\n                    positionIndex: this._getPositionIndex(value),\n                    keyGroup: this._getKeyGroup(this._rawKeys[index])\n                };\n            }\n        }, this);\n    },\n\n    /**\n     * Return key type.\n     * @param {string} key A key value \n     * @returns {string} A key type\n     * @private\n     */\n    _getKeyGroup: function(key) {\n        var keyGroup;\n        if(tui.util.isExisty(this._fixedKeys[key])) {\n            keyGroup = 'function';\n        } else {\n            if(key === '') {\n                keyGroup = 'blank';\n            } else {\n                keyGroup = 'key';\n            }\n        }\n        return keyGroup;\n    },\n\n    /**\n     * return index keys in virtual keyboard\n     * @param {string} key A key value \n     * @returns {number} A key index\n     * @private\n     */\n    _getPositionIndex: function(key) {\n        var i = 0,\n            length = this._keySequences.length;\n\n        for(; i &lt; length; i++) {\n            if(key === this._keySequences[i]) {\n                return i;\n            }\n        }\n    },\n\n    /**\n     * Initialize VirtualKeyboard.\n     * @param {string} containerId A container id\n     * @private\n     */\n    _initKeyboard: function(containerId) {\n        this._initContainer(containerId);\n        this._arrangeKeys();\n    },\n\n    /**\n     * Initialize container\n     * @param {string} containerId A container id\n     * @private\n     */\n    _initContainer: function(containerId) {\n        if(this._$container) {\n            tui.util.forEach(this._identifiedRawKeys, function(value) {\n                this._documentFragment.appendChild(this._keyMap[value].element);\n            }, this);\n        } else {\n            this._$container = $('#' + containerId);\n            if(!tui.util.isHTMLTag(this._$container[0])) {\n                this._$container = this._createContainer();\n            }\n        }\n    },\n\n    /**\n     * Create VirtualKeyboard container\n     * @returns {element}\n     * @private\n     */\n    _createContainer: function() {\n        var containerId = 'vk-' + this._getTime(),\n            container = $('&lt;ul id=' + containerId + '>');\n        $(document.body).append(container);\n        return container;\n    },\n\n    /**\n     * Return current time\n     * @returns {millisecond} Date time by millisecond\n     * @private\n     */\n    _getTime: function() {\n        var timeStamp;\n        if(Date.now) {\n            timeStamp = Date.now() || new Date().getTime();\n        }\n        return timeStamp;\n    },\n\n    /**\n     * Arrange keys in virtual keyboard.\n     * @private\n     */\n    _arrangeKeys: function() {\n        var keyElement;\n        tui.util.forEach(this._keySequences, function(value) {\n            keyElement = this._keyMap[value].element;\n            if(!tui.util.isHTMLTag(keyElement)) {\n                this._keyMap[value].element = keyElement = this._createKeyElement(value);\n            }\n            this._$container.append(keyElement);\n        }, this);\n    },\n\n    /**\n     * Return template by key.\n     * @param {string} keyGroup A key type to create\n     * @param {string} key A key to create\n     * @returns {string}\n     * @private\n     */\n    _getTemplate: function(keyGroup, key) {\n        var template;\n\n        if(keyGroup === 'blank') {\n            template = this._template.blank;\n        } else {\n            template = this._template[key] || this._template.key;\n        }\n\n        if(tui.util.isExisty(key)) {\n            template = template.replace(/{KEY}/g, key);\n        }\n        return template;\n    },\n\n    /**\n     * Create key button and return.\n     * @param {string} key A keys to create\n     * @returns {element} A key button element\n     * @private\n     */\n    _createKeyElement: function(key) {\n        var keyGroup = this._keyMap[key].keyGroup,\n            template = this._getTemplate(keyGroup, key),\n            keyElement = $(template),\n            buttonElement = keyElement.find('button');\n\n        if(!buttonElement.val() &amp;&amp; tui.util.isExisty(key)) {\n            buttonElement.val(key);\n        }\n        return keyElement[0];\n    },\n\n    /**\n     * Shuffle the keys\n     * @param {array} rawKeys A keys that is shuffled\n     * @private\n     */\n    _reArrangeKeys: function(rawKeys) {\n        // Initailize exist keys\n        this._rawKeys.length = 0;\n        this._keySequences.length = 0;\n\n        this._copyArray(rawKeys, this._rawKeys);\n        this._arrangeKeySequence();\n        this._refineFloatingKeys();\n        this._arrangeKeys();\n    },\n\n    /**\n     * Run custom callback\n     * @param {string} callbackKey The keys for callback function\n     * @param {number} [rawIndex] The typed index numberd\n     * @private\n     */\n    _executeCallback: function(callbackKey, rawIndex) {\n        if(tui.util.isExisty(this._callback, callbackKey) &amp;&amp; tui.util.isFunction(this._callback[callbackKey])) {\n            this._callback[callbackKey](rawIndex);\n        }\n    },\n\n    /**\n     * Get keyboard array\n     * @param {boolean} isCaseToggle Whether change case or not\n     * @private\n     */\n    _getRawKeys: function(isCaseToggle) {\n        var rawKeys;\n        if(tui.util.isExisty(this._callback, 'getKeys') &amp;&amp; tui.util.isFunction(this._callback.getKeys)) {\n            if(isCaseToggle) {\n                // Not shuffled, only get other case array.\n                rawKeys = this._callback.getKeys(this._currentKeyType, this._isCapsLock, true);\n            } else {\n                // Get new keys information array\n                rawKeys = this._callback.getKeys(this._currentKeyType, this._isCapsLock);\n            }\n        }\n        if(tui.util.isArray(rawKeys)) {\n            this._reArrangeKeys(rawKeys);\n        }\n    },\n\n    /**\n     * Shuffle keys.\n     * @api\n     * @example\n     *  virtualKeyboard.shuffle();\n     */\n    shuffle: function() {\n        // Reset exist values\n        this._keySequences.length = 0;\n        this._initContainer();\n        this._getRawKeys();\n    },\n\n    /**\n     * Toggle Eng/Kor.\n     * @api\n     * @example\n     *  virtualKeyboard.language();\n     */\n    language: function() {\n        this._initContainer();\n        this._isEnglish = !this._isEnglish;\n        this._currentKeyType = this._isEnglish ? 'english' : 'korean';\n        this._getRawKeys();\n    },\n\n    /**\n     * Change upper/lower case.\n     * @api\n     * @example\n     *  virtualKeyboard.caps();\n     */\n    caps: function() {\n        this._initContainer();\n        this._isCapsLock = !this._isCapsLock;\n        this._getRawKeys(true);\n    },\n\n    /**\n     * Change symbol/number keys\n     * @api\n     * @example\n     *  virtualKeyboard.symbol();\n     */\n    symbol: function() {\n        this._initContainer();\n        this._isSymbol = !this._isSymbol;\n        this._currentKeyType = this._isSymbol ? 'symbol' : 'number';\n        this._getRawKeys();\n    },\n\n    /**\n     * Remove the last typed/touched value\n     */\n    remove: function() {\n    },\n\n    /**\n     * Reset all typed keys.\n     */\n    clear: function() {\n    },\n\n    /**\n     * Insert blank\n     */\n    space: function() {\n    },\n\n    /**\n     * Open virtual keyboard\n     * @api\n     * @example\n     *  virtualKeyboard.open();\n     */\n    open: function() {\n        this.shuffle();\n        this._$container.show();\n    },\n\n    /**\n     * Close virtual keyboard\n     * @api\n     * @example\n     *  virtualKeyboard.close();\n     */\n    close: function() {\n        this.clear();\n        this._$container.hide();\n    },\n\n    /**\n     * Close viertual keyboard with complate button.\n     */\n    done: function() {\n        this.close();\n    }\n});\n\nmodule.exports = VirtualKeyboard;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"